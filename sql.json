{
    "simpleif": {
        "prefix": "sql-if",
        "body": [
            "IF (jsondata->>'media' is not null) THEN",
            "    NEW.channel = jsondata->>'media';",
            "END IF;"
        ],
        "description": "SQL Simple IF"
    },
    "simplecase": {
        "prefix": "sql-case",
        "body": [
            "SELECT CASE WHEN (jsondata->>'media') IS NULL THEN",
            "    'aaaa'",
            "ELSE",
            "    jsondata->>'media'",
            "END",
            "FROM chassi_contacts"
        ],
        "description": "SQL Simple Case"
    },
    "createtable": {
        "prefix": "sql-newtable",
        "body": [
            "CREATE TABLE NAME (",
            "  id serial PRIMARY KEY,",
            "  created TIMESTAMP NOT NULL DEFAULT now(),",
            "  updated TIMESTAMP NOT NULL DEFAULT now(),",
            "  UNIQUE(FIELD)",
            ");"
        ],
        "description": "SQL New Table"
    },
    "procedure": {
        "prefix": "sql-procedure",
        "body": [
            "",
            "CREATE FUNCTION PROCEDURENAME()",
            "    RETURNS trigger",
            "    LANGUAGE 'plpgsql'",
            "    COST 100",
            "AS \\$\\$",
            "BEGIN",
            "",
            "  if ((new.status != 'online') AND (old.status = 'online')) then",
            "    new.end_contact = now();",
            "    new.total_time = new.end_contact - old.created;",
            "  end if;",
            "",
            "  return new;",
            "END;",
            "\\$\\$; LANGUAGE plpgsql;"
        ],
        "description": "SQL New Table"
    },
    "trigger": {
        "prefix": "sql-trigger",
        "body": [
            "CREATE OR REPLACE FUNCTION calc_logged_time()",
            "RETURNS TRIGGER AS \\$\\$",
            "BEGIN",
            "\tIF NEW.start_time IS NOT NULL AND NEW.end_time IS NOT NULL THEN",
            "\t\tNEW.logged_time := NEW.end_time - NEW.start_time;",
            "\tELSE",
            "\t\tNEW.logged_time := NULL;",
            "\tEND IF;",
            "\tRETURN NEW;",
            "END;",
            "\\$\\$ LANGUAGE plpgsql;",
            "",
            "CREATE TRIGGER calc_logged_time",
            "BEFORE UPDATE ON sua_tabela",
            "FOR EACH ROW",
            "EXECUTE FUNCTION calc_logged_time();"
        ],
        "description": "SQL New Table"
    },
    "functionReturnBoolean": {
        "prefix": "sql-function-return-boolean",
        "body": [
            "CREATE OR REPLACE FUNCTION fc_name(",
            "   p1 character varying,",
            "   p2 integer",
            ")",
            "  RETURNS boolean",
            "AS \\$\\$",
            "DECLARE",
            "  reg record;",
            "BEGIN",
            "",
            "  DELETE FROM chats;",
            "",
            "  FOR reg in",
            "    SELECT tel.numero, tel.ddd, tel.operadora",
            "      FROM meuesquema.telefone tel",
            "  LOOP",
            "    RETURN NEXT reg;",
            "  END LOOP;",
            "",
            "  RETURN true;",
            "END;",
            "\\$\\$ LANGUAGE plpgsql;"
        ],
        "description": "SQL function"
    },
    "functionReturnTable": {
        "prefix": "sql-function-return-table-with-for",
        "body": [
            "CREATE OR REPLACE FUNCTION fc_name(",
            "   p1 integer",
            ")",
            "  RETURNS TABLE(r_id integer, r_name character varying)",
            "AS \\$\\$",
            "DECLARE",
            "  v1 record;",
            "BEGIN",
            "",
            "  FOR v1 IN",
            "     select d.id, d.name",
            "       from dashlets d",
            "      where d.id not in (select dashlet_id ",
            "                    from user_dashlets",
            "                    where user_id = p1)",
            "  LOOP",
            "    r_id   := v1.id;",
            "    r_name := v1.name;",
            "    RETURN NEXT;",
            "  END LOOP;",
            "  RETURN;",
            "END;",
            "\\$\\$ LANGUAGE plpgsql;"
        ],
        "description": "SQL function"
    },
    "json-select": {
        "prefix": "sql-jsonb-simple-select",
        "body": [
            "SELECT jsondata->>'media', jsondata->'sys'->>'ani' FROM chassi_contacts;",
            "SELECT * FROM chassi_contacts WHERE jsondata->>'media' IN ('message', 'voice');",
            "SELECT * FROM chassi_contacts WHERE jsondata @> '{\"media\": [\"message\"]}';",
            "SELECT * FROM chassi_contacts WHERE jsondata @> '{\"sys\": {\"ani\": \"103\"}}';",
            "UPDATE users SET jsondata = jsondata || '{\"media\": \"voice\"}';"
        ],
        "description": "SQL Jsonb SimpleSelect"
    },
    "json-loop": {
        "prefix": "sql-loop",
        "body": [
            "CREATE OR REPLACE FUNCTION test(",
            "  p1 int[],",
            "  p2 character varying",
            ")",
            "RETURNS setof integer",
            "  OR",
            "RETURNS character varying",
            "AS \\$\\$",
            "DECLARE",
            "  l_value INT;",
            "BEGIN",
            "  FOREACH l_value IN ARRAY p_input",
            "  LOOP",
            "    return next l_value;",
            "  END LOOP;",
            "",
            "  FOR reg in",
            "    SELECT tel.numero, tel.ddd, tel.operadora",
            "      FROM meuesquema.telefone tel",
            "  LOOP",
            "    RETURN NEXT reg;",
            "  END LOOP;",
            "",
            "END;",
            "\\$\\$ LANGUAGE plpgsql;"
        ],
        "description": "SQL Jsonb SimpleSelect"
    },
    "sqlWhenToTimestamp": {
        "prefix": [
            "sql-when-to-timestamp",
            "sql-gettime-to-timestamp"
        ],
        "body": [
            "select to_timestamp(1679088922069/1000),",
            "to_timestamp('1679088922069'::float/1000),",
            "to_timestamp('1679088922069'::float/1000);",
            "to_timestamp(new.portal_segment_end::float/1000) - to_timestamp(new.portal_segment_start::float/1000)"
        ],
        "description": "SQL Jsonb SimpleSelect"
    },
    "sqlOutputArray": {
        "prefix": [
            "sql-output-array",
            "sql-select-to-array"
        ],
        "body": [
            "SELECT",
            "  string_agg(id::text, ',') AS ids,",
            "  string_agg(name, ',') AS names,",
            "  string_agg(email, ',') AS emails",
            "FROM users;"
        ],
        "description": "SQL Agregação de Strings"
    },
    "metric-abandonmentRate-function": {
        "prefix": "sql-function-return-table",
        "body": [
            "CREATE OR REPLACE FUNCTION fcname(",
            "\tstart_time timestamp,",
            "\tend_time timestamp",
            ")",
            "RETURNS TABLE(",
            "\ttme float,",
            "\tbucket timestamp",
            ")",
            "AS \\$\\$",
            "DECLARE",
            "\ttme_var float;",
            "\tbucket_var timestamp;",
            "BEGIN",
            "",
            "\tSELECT AVG(measure), time_bucket('15 minutes', time)",
            "\t\tINTO tme_var, bucket_var",
            "\t\tFROM answer_time",
            "\t\tWHERE (time BETWEEN start_time AND end_time)",
            "\t\t\tAND tags->>'type' = 'queue'",
            "\t\t\tAND measure is not null",
            "\t\tGROUP BY time_bucket('15 minutes', time);",
            "",
            "\tRETURN QUERY",
            "\tSELECT tme_var, bucket_var;",
            "",
            "END;",
            "\\$\\$ LANGUAGE plpgsql;",
            "",
            "select * from fcname('2023-01-01 0:0', '2023-12-31 0:0');"
        ],
        "description": "Calculate abandonment rate based on start and end time"
    },
    "selectCurrentDate": {
        "prefix": [
            "sql-select-current-date",
            "sql-select-structure",
            "sql-select-join-lateral",
            "sql-select-elegant"
        ],
        "body": [
            "SELECT",
            "\tu.name, u.extension, p.pause_label",
            "FROM",
            "\tagent_access_histories a",
            "JOIN",
            "\tusers u ON u.id = a.user_id",
            "JOIN",
            "\troles r ON r.id = u.role_id",
            "LEFT JOIN LATERAL (",
            "\tSELECT pause_label",
            "\tFROM agent_access_histories",
            "\tWHERE user_id = u.id",
            "\t\tAND access_type != 'login'",
            "\tORDER BY start_time DESC",
            "\tLIMIT 1",
            ") AS p ON true",
            "WHERE",
            "\ta.start_time::date = CURRENT_DATE",
            "\tAND r.alias IN ('admin', 'agent')",
            "GROUP BY",
            "\tu.name, u.extension, u.status, p.pause_label",
            "ORDER BY",
            "\tu.name ASC;"
        ],
        "description": "Select query in SQL"
    },
    "roundTwoDecimal": {
        "prefix": "sql-round-2-decimal",
        "body": [
            "CREATE FUNCTION two_decimals()",
            "RETURNS TABLE (",
            "\tavailable bigint,",
            "\tavailable_percentual numeric(10,2),",
            "\ttotal bigint",
            ") AS",
            "$$",
            "DECLARE",
            "\tavailable_var BIGINT;",
            "\tlogged_var BIGINT;",
            "BEGIN",
            "\tSELECT",
            "\t\tSUM(CASE WHEN pause_label = 'available' THEN 1 ELSE 0 END) AS available,",
            "\t\tSUM(CASE WHEN pause_label IS NULL THEN 1 ELSE 0 END) AS logged",
            "\tINTO",
            "\t\tavailable_var,",
            "\t\tlogged_var",
            "\tFROM",
            "\t\t(",
            "\t\t\tSELECT",
            "\t\t\t\ta.user_id,",
            "\t\t\t\tMAX(a.pause_label) AS pause_label",
            "\t\t\tFROM",
            "\t\t\t\tagent_access_histories a",
            "\t\t\tWHERE",
            "\t\t\t\ta.end_time IS NULL",
            "\t\t\tGROUP BY",
            "\t\t\t\ta.user_id",
            "\t\t) AS latest_pause",
            "\tGROUP BY",
            "\t\tpause_label;",
            "",
            "\tRETURN QUERY SELECT",
            "\t\tavailable_var,",
            "\t\tROUND(available_var * 100.0 / logged_var, 2),",
            "\t\tlogged_var;",
            "END;",
            "$$",
            "LANGUAGE plpgsql;"
        ],
        "description": "Returns numeric2 information"
    }
}